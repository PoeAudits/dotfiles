#!/bin/bash
# Chezmoi run_once script: Setup GPG and SSH keys for this machine
# This script runs once per machine (tracked by chezmoi)
#
# Per-machine key strategy: Each machine has its own GPG/SSH keys.
# This enables individual key revocation if a machine is compromised.

set -Eeuo pipefail

# Configuration from chezmoi template
HOSTNAME="{{ .chezmoi.hostname }}"
GIT_NAME="{{ .git.name }}"
GIT_EMAIL="{{ .git.email }}"
KEY_DIR="$HOME/.gnupg/public-keys"

# ============================================================================
# Logging Functions
# ============================================================================

log_info() {
    echo "[Key Setup] $*"
}

log_warn() {
    echo "[Key Setup] WARNING: $*" >&2
}

log_error() {
    echo "[Key Setup] ERROR: $*" >&2
}

# ============================================================================
# GPG Functions
# ============================================================================

check_gpg_installed() {
    if ! command -v gpg &>/dev/null; then
        log_error "GPG is not installed. Please install it first:"
        echo "  Arch: sudo pacman -S gnupg"
        echo "  Ubuntu: sudo apt install gnupg"
        exit 1
    fi
}

# Find GPG key ID for this hostname
find_gpg_key_for_hostname() {
    local key_id
    key_id=$(gpg --list-keys --with-colons 2>/dev/null | \
        awk -F: -v hostname="$HOSTNAME" '
            /^fpr:/ { current_fpr = $10 }
            /^uid:/ && tolower($10) ~ tolower(hostname) { print current_fpr; exit }
        ')
    echo "$key_id"
}

# Check if key has encryption subkey
key_has_encryption_subkey() {
    local key_id="$1"
    gpg --list-keys --with-colons "$key_id" 2>/dev/null | grep -q "^sub:.*:e:"
}

# Generate GPG key with encryption capability
generate_gpg_key() {
    local key_uid="$GIT_NAME ($HOSTNAME) <$GIT_EMAIL>"
    
    log_info "Generating GPG key: $key_uid"
    
    # Generate primary signing key
    gpg --batch --passphrase "" --pinentry-mode loopback --quick-gen-key "$key_uid" rsa4096 sign 3y
    
    # Get the new key ID
    local key_id
    key_id=$(find_gpg_key_for_hostname)
    
    if [[ -z "$key_id" ]]; then
        log_error "Failed to generate GPG key"
        return 1
    fi
    
    log_info "Generated primary key: $key_id"
    
    # Add encryption subkey
    log_info "Adding encryption subkey..."
    gpg --batch --passphrase "" --pinentry-mode loopback --quick-add-key "$key_id" rsa4096 encr 3y
    
    log_info "GPG key generation complete"
    echo "$key_id"
}

# Export public key to file
export_gpg_public_key() {
    local key_id="$1"
    local export_file="$KEY_DIR/${HOSTNAME}.asc"
    local home_export="$HOME/${HOSTNAME}.pub.asc"

    # Create directory if needed
    if [[ ! -d "$KEY_DIR" ]]; then
        mkdir -p "$KEY_DIR"
        chmod 700 "$KEY_DIR"
    fi

    # Export to both locations
    if gpg --armor --export "$key_id" > "$export_file" 2>/dev/null; then
        chmod 644 "$export_file"
        cp "$export_file" "$home_export"
        log_info "Exported public key to:"
        log_info "  - $export_file"
        log_info "  - $home_export"
    else
        log_warn "Failed to export public key"
    fi
}

# Display GPG key info
show_gpg_key_info() {
    local key_id="$1"
    echo ""
    echo "GPG Key:"
    gpg --list-keys --keyid-format LONG "$key_id" 2>/dev/null
    echo ""
}

# ============================================================================
# SSH Functions
# ============================================================================

# Check if SSH key exists
ssh_key_exists() {
    [[ -f "$HOME/.ssh/id_ed25519" ]]
}

# Generate SSH key
generate_ssh_key() {
    local ssh_dir="$HOME/.ssh"
    
    log_info "Generating SSH key..."
    
    # Create .ssh directory if needed
    if [[ ! -d "$ssh_dir" ]]; then
        mkdir -p "$ssh_dir"
        chmod 700 "$ssh_dir"
    fi
    
    # Generate key (non-interactive, no passphrase)
    ssh-keygen -t ed25519 -C "$GIT_EMAIL" -f "$ssh_dir/id_ed25519" -N ""
    
    log_info "SSH key generated: $ssh_dir/id_ed25519"
}

# Display SSH public key
show_ssh_public_key() {
    echo ""
    echo "SSH Public Key:"
    cat "$HOME/.ssh/id_ed25519.pub"
    echo ""
}

# ============================================================================
# Post-Setup Instructions
# ============================================================================

show_next_steps() {
    local gpg_key_id="$1"
    
    cat <<EOF

================================================================================
Key Setup Complete
================================================================================

GPG Key ID: $gpg_key_id
SSH Key:    ~/.ssh/id_ed25519.pub

NEXT STEPS (Manual):

1. Add SSH key to GitHub:
   - Go to: https://github.com/settings/keys
   - Click "New SSH key"
   - Title: $HOSTNAME
   - Paste this key:

$(cat "$HOME/.ssh/id_ed25519.pub")

   - Or use GitHub CLI: gh ssh-key add ~/.ssh/id_ed25519.pub --title "$HOSTNAME"

2. Test GitHub SSH connection:
   ssh -T git@github.com

3. On an EXISTING machine with pass access, run:

   # Import the new machine's GPG public key
   ssh user@$HOSTNAME "cat ~/.gnupg/public-keys/${HOSTNAME}.asc" | gpg --import

   # Trust the key
   gpg --edit-key $gpg_key_id
   # Type: trust, 5, y, quit

   # Add to pass and re-encrypt
   cd ~/.password-store
   echo "$gpg_key_id" >> .gpg-id
   pass init \$(cat .gpg-id)
   pass git push

4. Back on THIS machine ($HOSTNAME), clone password store:
   git clone git@github.com:PoeAudits/password-store.git ~/.password-store
   pass ls

For detailed instructions, see: GPG-GUIDE.md

================================================================================

EOF
}

# ============================================================================
# Main
# ============================================================================

main() {
    log_info "Setting up keys for: $HOSTNAME"
    
    # Check GPG is installed
    check_gpg_installed
    
    # --- GPG Key Setup ---
    local gpg_key_id
    gpg_key_id=$(find_gpg_key_for_hostname)
    
    if [[ -n "$gpg_key_id" ]]; then
        log_info "Found existing GPG key: $gpg_key_id"
        
        # Check for encryption subkey
        if ! key_has_encryption_subkey "$gpg_key_id"; then
            log_warn "GPG key missing encryption subkey! Adding one..."
            gpg --batch --passphrase "" --pinentry-mode loopback --quick-add-key "$gpg_key_id" rsa4096 encr 3y
            log_info "Added encryption subkey"
        fi
    else
        log_info "No GPG key found, generating..."
        gpg_key_id=$(generate_gpg_key)
    fi
    
    show_gpg_key_info "$gpg_key_id"
    export_gpg_public_key "$gpg_key_id"
    
    # --- SSH Key Setup ---
    if ssh_key_exists; then
        log_info "SSH key already exists"
    else
        generate_ssh_key
    fi
    
    show_ssh_public_key
    
    # --- Show Next Steps ---
    show_next_steps "$gpg_key_id"
    
    log_info "Key setup complete for $HOSTNAME"
}

main "$@"
